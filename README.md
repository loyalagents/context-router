# Context Router

A NestJS GraphQL monolith built with Prisma and PostgreSQL, designed with clean separation for easy microservice migration.

## Tech Stack

- **Framework**: NestJS
- **API**: GraphQL with Apollo Server
- **Database**: PostgreSQL
- **ORM**: Prisma
- **Language**: TypeScript
- **Containerization**: Docker & Docker Compose

## Project Structure

```
src/
├── main.ts                      # Application bootstrap
├── app.module.ts                # Root module
├── config/                      # Configuration files
│   ├── app.config.ts
│   ├── database.config.ts
│   └── graphql.config.ts
├── common/                      # Shared utilities
│   ├── decorators/
│   ├── filters/
│   ├── interceptors/
│   ├── guards/
│   ├── pipes/
│   ├── exceptions/
│   └── utils/
├── infrastructure/              # Infrastructure layer
│   ├── prisma/
│   │   ├── prisma.module.ts
│   │   └── prisma.service.ts
│   ├── cache/
│   └── http/
├── graphql/                     # GraphQL-specific code
│   ├── scalars/
│   ├── plugins/
│   └── loaders/
└── modules/                     # Feature modules
    ├── user/
    │   ├── user.module.ts
    │   ├── user.service.ts
    │   ├── user.resolver.ts
    │   ├── user.repository.ts
    │   ├── dto/
    │   └── models/
    ├── auth/
    ├── health/
    └── system/
```

## Getting Started

### Prerequisites

- Docker & Docker Compose
- Node.js 20+ (for local development without Docker)

### Running with Docker

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd context-router
   ```

2. **Copy environment variables**
   ```bash
   cp .env.example .env
   ```

3. **Start the application**
   ```bash
   docker-compose up -d
   ```

4. **Run Prisma migrations**
   ```bash
   docker-compose exec app npx prisma migrate dev --name init
   ```

5. **Seed the database (optional)**
   ```bash
   docker-compose exec app pnpm run prisma:seed
   ```

6. **Access the application**
   - API: http://localhost:3000
   - GraphQL Playground: http://localhost:3000/graphql
   - Health Check: http://localhost:3000/health

### Local Development (without Docker)

1. **Install dependencies**
   ```bash
   pnpm install
   ```

2. **Start PostgreSQL** (via Docker)
   ```bash
   docker-compose up postgres -d
   ```

3. **Run migrations**
   ```bash
   pnpm run prisma:migrate
   ```

4. **Start development server**
   ```bash
   pnpm run start:dev
   ```

## Available Scripts

### Backend (apps/backend)
- `pnpm --filter backend build` - Build the application
- `pnpm --filter backend start` - Start the application
- `pnpm --filter backend start:dev` - Start in development mode with watch
- `pnpm --filter backend start:prod` - Start in production mode
- `pnpm --filter backend prisma:generate` - Generate Prisma Client
- `pnpm --filter backend prisma:migrate` - Run database migrations
- `pnpm --filter backend prisma:studio` - Open Prisma Studio
- `pnpm --filter backend prisma:seed` - Seed the database

### Frontend (apps/web)
- `pnpm --filter web run dev` - Start Next.js dev server (port 3002)
- `pnpm --filter web run build` - Build Next.js app
- `pnpm --filter web run codegen` - Generate TypeScript types from GraphQL schema
- `pnpm --filter web run codegen:watch` - Watch mode for type generation

## GraphQL Code Generation

The frontend uses [GraphQL Code Generator](https://the-guild.dev/graphql/codegen) to automatically generate TypeScript types from the backend GraphQL schema. This ensures type safety and keeps frontend types in sync with the backend.

### How It Works

1. **Schema File**: Reads from `apps/backend/src/schema.gql` (auto-generated by backend on startup)
2. **Document Scanning**: Scans frontend files for `gql` queries and mutations
3. **Type Generation**: Generates TypeScript types in `apps/web/lib/generated/graphql.ts`

**No Docker required!** Codegen reads directly from the schema file.

### Usage

**Generate types (no Docker needed!):**
```bash
pnpm --filter web run codegen
```

**Watch mode (auto-regenerate on changes):**
```bash
pnpm --filter web run codegen:watch
```

### Example

**Before (manual types):**
```typescript
interface MeQueryResponse {
  me: {
    userId: string;
    email: string;
    // ... manually defined
  };
}

const { data } = await client.query<MeQueryResponse>({ ... });
```

**After (generated types):**
```typescript
import { MeQuery } from '@/lib/generated/graphql';

const { data } = await client.query<MeQuery>({ ... });
// Types are auto-generated and always match the backend schema!
```

### When to Regenerate Types

**For Frontend Developers:**
- After pulling changes that include `apps/backend/src/schema.gql` updates
- After adding/modifying GraphQL queries or mutations in the frontend
- When setting up the project for the first time

**For Backend Developers (when schema changes):**
1. Start backend to regenerate `schema.gql`:
   ```bash
   docker-compose up -d
   # Wait for backend to start (generates schema.gql)
   docker-compose down
   ```
2. Commit the updated schema file:
   ```bash
   git add apps/backend/src/schema.gql
   git commit -m "Update GraphQL schema"
   ```
3. Frontend developers then:
   ```bash
   git pull
   pnpm --filter web run codegen
   ```

**Note:**
- Schema file (`apps/backend/src/schema.gql`) is committed to git
- Generated types (`apps/web/lib/generated/`) are in `.gitignore`

## GraphQL API

### Queries

```graphql
# Get all users
query {
  users {
    userId
    email
    firstName
    lastName
    createdAt
    updatedAt
  }
}

# Get a single user
query {
  user(id: "user-id-here") {
    userId
    email
    firstName
    lastName
  }
}
```

### Mutations

```graphql
# Create a user
mutation {
  createUser(createUserInput: {
    email: "john@example.com"
    firstName: "John"
    lastName: "Doe"
  }) {
    userId
    email
    firstName
    lastName
  }
}

# Update a user
mutation {
  updateUser(updateUserInput: {
    userId: "user-id-here"
    firstName: "Jane"
  }) {
    userId
    firstName
  }
}

# Delete a user
mutation {
  removeUser(id: "user-id-here") {
    userId
    email
  }
}
```

## Architecture Decisions

### Layered Architecture
- **Resolver**: GraphQL API layer
- **Service**: Business logic (stateless, testable)
- **Repository**: Data access abstraction (wraps Prisma)

### Microservice Ready
Each module is self-contained with clear boundaries:
- Domain logic isolated in services
- Data access abstracted in repositories
- GraphQL resolvers can be swapped for REST/gRPC

### Infrastructure Abstraction
Database and external dependencies are isolated in the infrastructure layer, making it easy to swap implementations.

## Docker Services

- **postgres**: PostgreSQL database (port 5432)
- **app**: NestJS application (port 3000)

## Environment Variables

See `.env.example` for all available configuration options.

## License

ISC